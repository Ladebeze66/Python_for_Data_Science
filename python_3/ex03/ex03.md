# Exercice 03 : Calculate my vector - Surcharge d'op√©rateurs et op√©rations vectorielles

## üìã Objectifs p√©dagogiques

### Concepts cl√©s abord√©s :
- **M√©thodes magiques** : Surcharge des op√©rateurs arithm√©tiques (`+`, `-`, `*`, `/`)
- **Op√©rations vectorielles** : Application d'une op√©ration scalaire √† tous les √©l√©ments d'un vecteur
- **List comprehensions** : Syntaxe concise pour les transformations de listes
- **Gestion d'exceptions** : Lev√©e et capture de `ZeroDivisionError`
- **Modification in-place** : Transformation de l'objet original
- **Type hints** : Annotations de type avec `-> None`

### Comp√©tences d√©velopp√©es :
- Ma√Ætrise des m√©thodes magiques Python
- Compr√©hension des op√©rations vectorielles
- Gestion appropri√©e des exceptions
- Conception d'API intuitive avec surcharge d'op√©rateurs

---

## üéØ Consignes de l'exercice

**R√©pertoire de rendu :** `ex03/`  
**Fichiers √† rendre :** `ft_calculator.py`  
**Fonctions autoris√©es :** Aucune

### Sp√©cifications :
1. Cr√©er une classe `calculator` pour les op√©rations vectorielles avec scalaires
2. Impl√©menter les m√©thodes magiques : `__add__`, `__mul__`, `__sub__`, `__truediv__`
3. Chaque op√©ration applique le scalaire √† tous les √©l√©ments du vecteur
4. Les op√©rations modifient le vecteur original et affichent le r√©sultat
5. Gestion d'erreur uniquement pour la division par z√©ro

### Comportement attendu :
- **Addition** : `vector + scalar` ‚Üí Ajoute le scalaire √† chaque √©l√©ment
- **Multiplication** : `vector * scalar` ‚Üí Multiplie chaque √©l√©ment par le scalaire
- **Soustraction** : `vector - scalar` ‚Üí Soustrait le scalaire de chaque √©l√©ment
- **Division** : `vector / scalar` ‚Üí Divise chaque √©l√©ment par le scalaire

---

## üîß √âl√©ments techniques

### Concepts Python utilis√©s :
- **M√©thodes magiques** : `__add__`, `__mul__`, `__sub__`, `__truediv__`
- **List comprehensions** : `[x + object for x in self.vector]`
- **Type hints** : `-> None` pour indiquer l'absence de valeur de retour
- **Gestion d'exceptions** : `raise ZeroDivisionError`
- **Modification in-place** : `self.vector = nouvelle_liste`

### M√©thodes magiques utilis√©es :
```python
__add__(self, other)    # Comportement de obj + other
__mul__(self, other)    # Comportement de obj * other
__sub__(self, other)    # Comportement de obj - other
__truediv__(self, other) # Comportement de obj / other
```

---

## üíª Impl√©mentation pas √† pas

### √âtape 1 : Structure de base de la classe

```python
class calculator:
    """Your docstring for Class"""

    def __init__(self, vector):
        """Your docstring for Constructor"""
        self.vector = vector
```

**Explication :**
- **Classe simple** : Pas d'h√©ritage, classe autonome
- **Constructeur** : Prend une liste (vecteur) en param√®tre
- **Stockage** : Sauvegarde du vecteur dans `self.vector`

### √âtape 2 : Impl√©mentation de l'addition

```python
    def __add__(self, object) -> None:
        """Your docstring for Method"""
        self.vector = [x + object for x in self.vector]
        print(self.vector)
```

**Explication :**
- **`__add__`** : M√©thode magique appel√©e par l'op√©rateur `+`
- **List comprehension** : `[x + object for x in self.vector]` applique l'addition √† chaque √©l√©ment
- **Modification in-place** : `self.vector = ...` remplace le vecteur original
- **Affichage automatique** : `print(self.vector)` affiche le r√©sultat
- **Type hint** : `-> None` indique qu'aucune valeur n'est retourn√©e

### √âtape 3 : Impl√©mentation de la multiplication

```python
    def __mul__(self, object) -> None:
        """Your docstring for Method"""
        self.vector = [x * object for x in self.vector]
        print(self.vector)
```

**Explication :**
- **`__mul__`** : M√©thode magique pour l'op√©rateur `*`
- **Multiplication vectorielle** : Chaque √©l√©ment est multipli√© par l'objet (scalaire)
- **M√™me pattern** : Modification + affichage

### √âtape 4 : Impl√©mentation de la soustraction

```python
    def __sub__(self, object) -> None:
        """Your docstring for Method"""
        self.vector = [x - object for x in self.vector]
        print(self.vector)
```

**Explication :**
- **`__sub__`** : M√©thode magique pour l'op√©rateur `-`
- **Soustraction vectorielle** : L'objet (scalaire) est soustrait de chaque √©l√©ment

### √âtape 5 : Impl√©mentation de la division avec gestion d'erreur

```python
    def __truediv__(self, object) -> None:
        """Your docstring for Method"""
        if object == 0:
            raise ZeroDivisionError("Cannot divide by zero")
        self.vector = [x / object for x in self.vector]
        print(self.vector)
```

**Explication :**
- **`__truediv__`** : M√©thode magique pour l'op√©rateur `/` (division "vraie")
- **Validation** : V√©rification `if object == 0` avant l'op√©ration
- **Exception** : `raise ZeroDivisionError` avec message explicite
- **Division vectorielle** : Chaque √©l√©ment divis√© par l'objet (scalaire)

---

## üß™ Tests et validation

### Code de test (tester.py) :

```python
from ft_calculator import calculator

def main():
    """Test function for ft_calculator module."""
    # Test addition
    v1 = calculator([0.0, 1.0, 2.0, 3.0, 4.0, 5.0])
    v1 + 5
    print("---")
    
    # Test multiplication
    v2 = calculator([0.0, 1.0, 2.0, 3.0, 4.0, 5.0])
    v2 * 5
    print("---")
    
    # Test soustraction et division
    v3 = calculator([10.0, 15.0, 20.0])
    v3 - 5
    v3 / 5
    print("---")
    
    # Test division par z√©ro
    v4 = calculator([1.0, 2.0, 3.0])
    try:
        v4 / 0
    except ZeroDivisionError as e:
        print(f"Erreur attendue: {e}")

if __name__ == "__main__":
    main()
```

### Sortie attendue :

```
[5.0, 6.0, 7.0, 8.0, 9.0, 10.0]
---
[0.0, 5.0, 10.0, 15.0, 20.0, 25.0]
---
[5.0, 10.0, 15.0]
[1.0, 2.0, 3.0]
---
Erreur attendue: Cannot divide by zero
```

### Analyse des r√©sultats :

**Test 1 - Addition :**
- Vecteur initial : `[0.0, 1.0, 2.0, 3.0, 4.0, 5.0]`
- Op√©ration : `+ 5`
- R√©sultat : `[5.0, 6.0, 7.0, 8.0, 9.0, 10.0]`

**Test 2 - Multiplication :**
- Vecteur initial : `[0.0, 1.0, 2.0, 3.0, 4.0, 5.0]`
- Op√©ration : `* 5`
- R√©sultat : `[0.0, 5.0, 10.0, 15.0, 20.0, 25.0]`

**Test 3 - Soustraction puis division :**
- Vecteur initial : `[10.0, 15.0, 20.0]`
- Apr√®s `- 5` : `[5.0, 10.0, 15.0]`
- Apr√®s `/ 5` : `[1.0, 2.0, 3.0]`

**Test 4 - Gestion d'erreur :**
- Division par z√©ro correctement intercept√©e
- Exception lev√©e avec message appropri√©

---

## üîç Analyse technique approfondie

### M√©thodes magiques et surcharge d'op√©rateurs :

**Principe :**
```python
obj + 5  # Appelle obj.__add__(5)
obj * 3  # Appelle obj.__mul__(3)
obj - 2  # Appelle obj.__sub__(2)
obj / 4  # Appelle obj.__truediv__(4)
```

**Avantages :**
- **Syntaxe naturelle** : `v + 5` plus lisible que `v.add(5)`
- **Int√©gration Python** : Utilise les m√©canismes natifs du langage
- **Polymorphisme** : M√™me interface pour diff√©rents types

### Op√©rations vectorielles :

**Concept math√©matique :**
- **Scalaire** : Nombre unique (ex: 5)
- **Vecteur** : Liste de nombres (ex: [1, 2, 3])
- **Op√©ration vectoriel-scalaire** : Application du scalaire √† chaque composante

**Impl√©mentation Python :**
```python
# Math√©matiquement : [a, b, c] + k = [a+k, b+k, c+k]
# En Python :
[x + object for x in vector]
```

### Gestion d'erreurs cibl√©e :

**Philosophie :**
- **Minimal** : Seulement les erreurs critiques (division par z√©ro)
- **Explicite** : Message d'erreur clair
- **Standard** : Utilisation d'exceptions Python standard

---

## ‚úÖ V√©rifications de conformit√©

### Respect des r√®gles g√©n√©rales :
- ‚úÖ Python 3.10 utilis√©
- ‚úÖ Imports explicites (aucun import externe n√©cessaire)
- ‚úÖ Aucune variable globale
- ‚úÖ Fonctions avec docstrings
- ‚úÖ Code conforme flake8

### Respect des instructions sp√©cifiques :
- ‚úÖ Pas de code dans le scope global (tester.py avec main())
- ‚úÖ Structure avec `if __name__ == "__main__"`
- ‚úÖ Toutes les classes/m√©thodes document√©es
- ‚úÖ Gestion d'exceptions appropri√©e (try/except pour division par z√©ro)

### Fonctionnalit√©s impl√©ment√©es :
- ‚úÖ Classe `calculator` fonctionnelle
- ‚úÖ Quatre m√©thodes magiques impl√©ment√©es
- ‚úÖ Op√©rations vectorielles correctes
- ‚úÖ Modification in-place des vecteurs
- ‚úÖ Affichage automatique des r√©sultats
- ‚úÖ Gestion d'erreur pour division par z√©ro
- ‚úÖ Sortie conforme aux sp√©cifications

---

## üéì Points cl√©s √† retenir

### Concepts POO et Python :
1. **M√©thodes magiques** : Permettent la surcharge d'op√©rateurs naturelle
2. **API intuitive** : `obj + 5` plus naturel que `obj.add(5)`
3. **Type hints** : `-> None` indique l'absence de valeur de retour
4. **Modification in-place** : L'objet est transform√©, pas copi√©

### Math√©matiques et algorithmique :
1. **Op√©rations vectorielles** : Concept fondamental en calcul scientifique
2. **Broadcasting** : Application d'un scalaire √† un vecteur
3. **Efficacit√©** : List comprehensions optimis√©es en Python
4. **Gestion d'erreurs** : Division par z√©ro est math√©matiquement ind√©finie

### Bonnes pratiques :
1. **Coh√©rence** : M√™me pattern pour toutes les op√©rations
2. **Validation** : V√©rification des conditions d'erreur
3. **Documentation** : Docstrings sur toutes les m√©thodes
4. **Tests** : Couverture compl√®te incluant les cas d'erreur

---

## ‚ö†Ô∏è Pi√®ges et difficult√©s

### Pi√®ges courants :
1. **Confusion `__div__` vs `__truediv__`** : Python 3 utilise `__truediv__`
2. **Modification vs copie** : Attention √† modifier l'original ou cr√©er une copie
3. **Type de retour** : `-> None` car pas de valeur retourn√©e
4. **Gestion d'erreurs** : Ne pas oublier la division par z√©ro

### Difficult√©s de l'exercice :
1. **M√©thodes magiques** : Comprendre le m√©canisme de surcharge
2. **List comprehensions** : Syntaxe concise mais √† ma√Ætriser
3. **Affichage automatique** : Comprendre qu'il faut imprimer dans la m√©thode
4. **Gestion d'exceptions** : √âquilibre entre robustesse et simplicit√©

---

## üöÄ Extensions possibles

Pour aller plus loin, vous pourriez :
1. **Op√©rations vectoriel-vectoriel** : Addition de deux vecteurs
2. **Op√©rations math√©matiques avanc√©es** : Produit scalaire, norme
3. **Validation d'entr√©e** : V√©rifier que l'input est bien un nombre
4. **Optimisation** : Utiliser NumPy pour de meilleures performances
5. **Op√©rateurs de comparaison** : `__eq__`, `__lt__`, etc.
6. **Op√©rateurs in-place** : `__iadd__`, `__imul__`, etc.
7. **Support de types** : Gestion d'entiers, complexes, etc.

### Exemple d'extension - Op√©rateurs in-place :
```python
def __iadd__(self, object):
    """Op√©rateur += in-place"""
    self.vector = [x + object for x in self.vector]
    return self  # Important : retourner self pour l'assignation
```

Cet exercice est une excellente introduction aux m√©thodes magiques Python et aux op√©rations vectorielles, concepts essentiels pour le calcul scientifique et la data science.