# Exercice 04 : Calculate my dot product - M√©thodes statiques et op√©rations vectorielles

## üìã Objectifs p√©dagogiques

### Concepts cl√©s abord√©s :
- **M√©thodes statiques** : Utilisation du d√©corateur `@staticmethod`
- **Op√©rations vectorielles** : Calculs entre deux vecteurs (produit scalaire, addition, soustraction)
- **Appel sans instanciation** : Utilisation de m√©thodes de classe sans cr√©er d'objet
- **Fonction `zip()`** : Parcours parall√®le de deux s√©quences
- **Produit scalaire** : Concept math√©matique fondamental en alg√®bre lin√©aire
- **Type hints avanc√©s** : `list[float]` pour les annotations de type

### Comp√©tences d√©velopp√©es :
- Ma√Ætrise des m√©thodes statiques en Python
- Compr√©hension des op√©rations vectorielles
- Utilisation efficace de `zip()` et des g√©n√©rateurs
- Conception d'API sans √©tat (stateless)

---

## üéØ Consignes de l'exercice

**R√©pertoire de rendu :** `ex04/`  
**Fichiers √† rendre :** `ft_calculator.py`  
**Fonctions autoris√©es :** Aucune

### Sp√©cifications :
1. Cr√©er une classe `calculator` avec des m√©thodes statiques
2. Impl√©menter trois op√©rations vectorielles :
   - `dotproduct` : Produit scalaire de deux vecteurs
   - `add_vec` : Addition √©l√©ment par √©l√©ment
   - `sous_vec` : Soustraction √©l√©ment par √©l√©ment
3. Utiliser des d√©corateurs pour permettre l'appel sans instanciation
4. Les vecteurs ont toujours des tailles identiques (pas de gestion d'erreurs)

### Comportement attendu :
- **Produit scalaire** : `V1 ‚Ä¢ V2 = Œ£(V1[i] * V2[i])`
- **Addition vectorielle** : `V1 + V2 = [V1[i] + V2[i] for i in range(len(V1))]`
- **Soustraction vectorielle** : `V1 - V2 = [V1[i] - V2[i] for i in range(len(V1))]`

---

## üîß √âl√©ments techniques

### Concepts Python utilis√©s :
- **@staticmethod** : D√©corateur pour cr√©er des m√©thodes statiques
- **zip()** : Fonction pour parcourir plusieurs s√©quences en parall√®le
- **G√©n√©rateurs** : `sum(x * y for x, y in zip(V1, V2))`
- **List comprehensions** : `[float(x + y) for x, y in zip(V1, V2)]`
- **Type hints** : `list[float]` pour les listes de nombres flottants
- **f-strings** : Formatage moderne des cha√Ænes

### M√©thodes statiques vs m√©thodes d'instance :
```python
# M√©thode d'instance (n√©cessite une instanciation)
obj = Calculator()
obj.method()

# M√©thode statique (appel direct sur la classe)
Calculator.method()
```

---

## üíª Impl√©mentation pas √† pas

### √âtape 1 : Structure de base avec m√©thodes statiques

```python
class calculator:
    """Your docstring for Class"""
    
    @staticmethod
    def dotproduct(V1: list[float], V2: list[float]) -> None:
        """Your docstring for Method"""
```

**Explication :**
- **@staticmethod** : D√©corateur qui transforme la m√©thode en m√©thode statique
- **Pas de `self`** : Les m√©thodes statiques n'ont pas acc√®s √† l'instance
- **Type hints** : `V1: list[float], V2: list[float]` exactement comme dans le prototype
- **-> None** : La m√©thode imprime mais ne retourne rien

### √âtape 2 : Impl√©mentation du produit scalaire

```python
    @staticmethod
    def dotproduct(V1: list[float], V2: list[float]) -> None:
        """Your docstring for Method"""
        result = sum(x * y for x, y in zip(V1, V2))
        print(f"Dot product is: {result}")
```

**Explication :**
- **Produit scalaire** : Somme des produits des √©l√©ments correspondants
- **zip(V1, V2)** : Cr√©e des paires (V1[0], V2[0]), (V1[1], V2[1]), etc.
- **G√©n√©rateur** : `(x * y for x, y in zip(V1, V2))` g√©n√®re les produits
- **sum()** : Additionne tous les produits
- **Formatage** : `"Dot product is: {result}"` respecte la sortie attendue

**Exemple math√©matique :**
```
V1 = [5, 10, 2]
V2 = [2, 4, 3]
Produit scalaire = 5*2 + 10*4 + 2*3 = 10 + 40 + 6 = 56
```

### √âtape 3 : Impl√©mentation de l'addition vectorielle

```python
    @staticmethod
    def add_vec(V1: list[float], V2: list[float]) -> None:
        """Your docstring for Method"""
        result = [float(x + y) for x, y in zip(V1, V2)]
        print(f"Add Vector is : {result}")
```

**Explication :**
- **Addition √©l√©ment par √©l√©ment** : Chaque √©l√©ment de V1 + √©l√©ment correspondant de V2
- **List comprehension** : `[float(x + y) for x, y in zip(V1, V2)]`
- **float()** : Conversion explicite pour garantir le type float dans la sortie
- **Formatage** : `"Add Vector is : "` avec espace apr√®s les deux points

**Exemple math√©matique :**
```
V1 = [5, 10, 2]
V2 = [2, 4, 3]
Addition = [5+2, 10+4, 2+3] = [7, 14, 5] ‚Üí [7.0, 14.0, 5.0]
```

### √âtape 4 : Impl√©mentation de la soustraction vectorielle

```python
    @staticmethod
    def sous_vec(V1: list[float], V2: list[float]) -> None:
        """Your docstring for Method"""
        result = [float(x - y) for x, y in zip(V1, V2)]
        print(f"Sous Vector is: {result}")
```

**Explication :**
- **Soustraction √©l√©ment par √©l√©ment** : V1[i] - V2[i] pour chaque position
- **M√™me pattern** que l'addition, mais avec l'op√©rateur `-`
- **Formatage** : `"Sous Vector is:"` sans espace apr√®s les deux points

**Exemple math√©matique :**
```
V1 = [5, 10, 2]
V2 = [2, 4, 3]
Soustraction = [5-2, 10-4, 2-3] = [3, 6, -1] ‚Üí [3.0, 6.0, -1.0]
```

---

## üß™ Tests et validation

### Code de test (tester.py) :

```python
from ft_calculator import calculator

def main():
    """Test function for ft_calculator module."""
    a = [5, 10, 2]
    b = [2, 4, 3]
    calculator.dotproduct(a, b)
    calculator.add_vec(a, b)
    calculator.sous_vec(a, b)

if __name__ == "__main__":
    main()
```

### Sortie attendue :

```
Dot product is: 56
Add Vector is : [7.0, 14.0, 5.0]
Sous Vector is: [3.0, 6.0, -1.0]
```

### Analyse des r√©sultats :

**Test du produit scalaire :**
- Vecteurs : `a = [5, 10, 2]`, `b = [2, 4, 3]`
- Calcul : `5√ó2 + 10√ó4 + 2√ó3 = 10 + 40 + 6 = 56`
- Sortie : `"Dot product is: 56"`

**Test de l'addition :**
- Addition : `[5+2, 10+4, 2+3] = [7, 14, 5]`
- Conversion : `[7.0, 14.0, 5.0]` (type float)
- Sortie : `"Add Vector is : [7.0, 14.0, 5.0]"`

**Test de la soustraction :**
- Soustraction : `[5-2, 10-4, 2-3] = [3, 6, -1]`
- Conversion : `[3.0, 6.0, -1.0]` (type float)
- Sortie : `"Sous Vector is: [3.0, 6.0, -1.0]"`

---

## üîç Analyse technique approfondie

### M√©thodes statiques en d√©tail :

**Avantages :**
- **Pas d'instanciation** : √âconomie de m√©moire et simplicit√© d'usage
- **Fonctions utilitaires** : Parfait pour des calculs math√©matiques purs
- **Namespace** : Organisation logique dans une classe sans √©tat

**Utilisation :**
```python
# Appel direct sur la classe
calculator.dotproduct([1, 2], [3, 4])

# Pas besoin de :
# calc = calculator()
# calc.dotproduct([1, 2], [3, 4])
```

### Fonction zip() et op√©rations vectorielles :

**Principe de zip() :**
```python
V1 = [5, 10, 2]
V2 = [2, 4, 3]
list(zip(V1, V2))  # [(5, 2), (10, 4), (2, 3)]
```

**Applications :**
```python
# Produit scalaire
sum(x * y for x, y in zip(V1, V2))

# Addition vectorielle
[x + y for x, y in zip(V1, V2)]

# Soustraction vectorielle
[x - y for x, y in zip(V1, V2)]
```

### Concepts math√©matiques :

**Produit scalaire (Dot Product) :**
- **D√©finition** : `V1 ‚Ä¢ V2 = Œ£(V1[i] √ó V2[i])`
- **R√©sultat** : Scalaire (nombre unique)
- **Applications** : Projection, similarit√©, angle entre vecteurs

**Op√©rations √©l√©ment par √©l√©ment :**
- **Addition** : `(V1 + V2)[i] = V1[i] + V2[i]`
- **Soustraction** : `(V1 - V2)[i] = V1[i] - V2[i]`
- **R√©sultat** : Vecteur de m√™me dimension

---

## ‚úÖ V√©rifications de conformit√©

### Respect des r√®gles g√©n√©rales :
- ‚úÖ Python 3.10 utilis√©
- ‚úÖ Imports explicites (aucun import externe n√©cessaire)
- ‚úÖ Aucune variable globale
- ‚úÖ Fonctions avec docstrings
- ‚úÖ Code conforme flake8

### Respect des instructions sp√©cifiques :
- ‚úÖ Pas de code dans le scope global (tester.py avec main())
- ‚úÖ Structure avec `if __name__ == "__main__"`
- ‚úÖ Toutes les classes/m√©thodes document√©es
- ‚úÖ Pas de gestion d'erreurs (selon sp√©cifications)

### Fonctionnalit√©s impl√©ment√©es :
- ‚úÖ Classe `calculator` avec m√©thodes statiques
- ‚úÖ Trois op√©rations vectorielles impl√©ment√©es
- ‚úÖ Appel sans instanciation fonctionnel
- ‚úÖ Type hints conformes au prototype
- ‚úÖ Formatage de sortie exact
- ‚úÖ Conversion en float des r√©sultats
- ‚úÖ Sortie conforme aux sp√©cifications

---

## üéì Points cl√©s √† retenir

### Concepts POO et Python :
1. **M√©thodes statiques** : Ind√©pendantes de l'√©tat de l'instance
2. **@staticmethod** : D√©corateur pour cr√©er des m√©thodes statiques
3. **Namespace** : Organisation logique sans n√©cessit√© d'instanciation
4. **Type hints** : `list[float]` pour les annotations modernes

### Math√©matiques et algorithmique :
1. **Alg√®bre lin√©aire** : Op√©rations vectorielles fondamentales
2. **Produit scalaire** : Concept cl√© en g√©om√©trie et data science
3. **Op√©rations √©l√©ment par √©l√©ment** : Base des calculs vectoriels
4. **Efficacit√©** : zip() et g√©n√©rateurs pour des calculs optimis√©s

### Bonnes pratiques :
1. **Fonctions pures** : Pas d'effets de bord (sauf affichage)
2. **S√©paration des responsabilit√©s** : Calcul vs affichage
3. **R√©utilisabilit√©** : Code modulaire et bien organis√©
4. **Lisibilit√©** : Code expressif et bien document√©

---

## ‚ö†Ô∏è Pi√®ges et difficult√©s

### Pi√®ges courants :
1. **Oublier @staticmethod** : M√©thode non appelable sans instanciation
2. **Mauvais type hints** : Utiliser `List` au lieu de `list[float]`
3. **Formatage de sortie** : Respecter exactement les espaces et deux points
4. **Type des r√©sultats** : Oublier la conversion en float

### Difficult√©s de l'exercice :
1. **Compr√©hension des m√©thodes statiques** : Concept parfois confus
2. **Produit scalaire** : Diff√©rence avec multiplication √©l√©ment par √©l√©ment
3. **Formatage pr√©cis** : Correspondre exactement √† la sortie attendue
4. **zip() et g√©n√©rateurs** : Syntaxe √† ma√Ætriser

---

## üöÄ Extensions possibles

Pour aller plus loin, vous pourriez :
1. **Autres op√©rations vectorielles** : Norme, normalisation, distance
2. **Validation d'entr√©e** : V√©rifier que les vecteurs ont la m√™me taille
3. **Support de matrices** : √âtendre aux op√©rations matricielles
4. **Optimisation NumPy** : Utiliser NumPy pour de meilleures performances
5. **Op√©rations complexes** : Produit vectoriel, angle entre vecteurs
6. **M√©thodes de classe** : Utiliser `@classmethod` pour d'autres patterns

### Exemple d'extension - Norme d'un vecteur :
```python
@staticmethod
def norm(V: list[float]) -> None:
    """Calculate the norm (magnitude) of a vector"""
    result = (sum(x * x for x in V)) ** 0.5
    print(f"Vector norm is: {result}")
```

### Exemple d'extension - Angle entre vecteurs :
```python
@staticmethod
def angle(V1: list[float], V2: list[float]) -> None:
    """Calculate angle between two vectors in radians"""
    import math
    dot_product = sum(x * y for x, y in zip(V1, V2))
    norm1 = (sum(x * x for x in V1)) ** 0.5
    norm2 = (sum(x * x for x in V2)) ** 0.5
    cos_angle = dot_product / (norm1 * norm2)
    angle_rad = math.acos(max(-1, min(1, cos_angle)))  # Clamp for numerical stability
    print(f"Angle between vectors: {angle_rad} radians")
```

Cet exercice est une excellente introduction aux m√©thodes statiques et aux op√©rations vectorielles, concepts essentiels pour l'alg√®bre lin√©aire et le calcul scientifique en Python.