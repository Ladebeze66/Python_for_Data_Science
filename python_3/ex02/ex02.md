# Exercice 02 : Now it's weird! - H√©ritage multiple et Properties

## üìã Objectifs p√©dagogiques

### Concepts cl√©s abord√©s :
- **H√©ritage multiple** : Classe h√©ritant de deux classes parentes
- **Diamond Problem** : Gestion de l'h√©ritage en diamant avec la lin√©arisation C3
- **Properties** : Utilisation de getters et setters avec `@property`
- **Method Resolution Order (MRO)** : Comprendre l'ordre de r√©solution des m√©thodes
- **Manipulation d'attributs** : Modification dynamique du dictionnaire d'instance
- **Incoh√©rence conceptuelle** : Joffrey "officiellement" Baratheon mais g√©n√©tiquement Lannister

### Comp√©tences d√©velopp√©es :
- Ma√Ætrise de l'h√©ritage multiple en Python
- Utilisation avanc√©e des properties
- Compr√©hension des m√©canismes internes de Python (MRO, `__dict__`)
- Gestion de cas complexes d'h√©ritage

---

## üéØ Consignes de l'exercice

**R√©pertoire de rendu :** `ex02/`  
**Fichiers √† rendre :** Fichiers des exercices pr√©c√©dents + `DiamondTrap.py`  
**Fonctions autoris√©es :** Aucune

### Sp√©cifications :
1. Cr√©er une classe `King` h√©ritant de `Baratheon` ET `Lannister`
2. Utiliser des Properties pour modifier les caract√©ristiques physiques
3. G√©rer l'incoh√©rence : Joffrey est "officiellement" Baratheon mais peut prendre les traits Lannister
4. Impl√©menter des m√©thodes `get_*` et `set_*` pour les attributs

### Le "monstre" Joffrey :
- **Probl√®me narratif** : Joffrey Baratheon est officiellement l'h√©ritier Baratheon, mais en r√©alit√© fils de Jaime Lannister
- **Probl√®me technique** : Comment repr√©senter cette dualit√© en POO ?

---

## üîß √âl√©ments techniques

### Imports n√©cessaires :
```python
from S1E7 import Baratheon, Lannister
```

### Concepts Python utilis√©s :
- **H√©ritage multiple** : `class King(Baratheon, Lannister)`
- **MRO (Method Resolution Order)** : Algorithme C3 de Python
- **@property** : D√©corateur pour cr√©er des properties
- **@property.setter** : D√©corateur pour cr√©er des setters
- **`__dict__`** : Manipulation directe du dictionnaire d'attributs
- **`super()`** : Appel des m√©thodes parentes dans un contexte d'h√©ritage multiple

---

## üíª Impl√©mentation pas √† pas

### √âtape 1 : H√©ritage multiple et MRO

```python
from S1E7 import Baratheon, Lannister

class King(Baratheon, Lannister):
    """Your docstring for Class"""
    
    def __init__(self, first_name: str, is_alive: bool = True):
        """Your docstring for Constructor"""
        super().__init__(first_name, is_alive)
        # Corriger l'attribut initial 'hairs' -> 'hair'
        if 'hairs' in self.__dict__:
            self.__dict__['hair'] = self.__dict__.pop('hairs')
```

**Explication :**
- `King(Baratheon, Lannister)` : H√©ritage multiple
- **MRO** : `King -> Baratheon -> Lannister -> Character -> ABC -> object`
- `super().__init__()` appelle le constructeur de `Baratheon` (premier dans la MRO)
- Correction initiale : `hairs` ‚Üí `hair` pour correspondre √† la sortie attendue

### √âtape 2 : Property pour les yeux

```python
    @property
    def eyes(self):
        """Your docstring for Method"""
        return self.__dict__.get('eyes', 'brown')
    
    @eyes.setter
    def eyes(self, value):
        """Your docstring for Method"""
        self.__dict__['eyes'] = value
```

**Explication :**
- `@property` : Transforme la m√©thode en attribut accessible
- `@eyes.setter` : D√©finit le comportement lors de l'assignation
- `self.__dict__.get('eyes', 'brown')` : Valeur par d√©faut si l'attribut n'existe pas
- Manipulation directe de `__dict__` pour contr√¥ler les attributs

### √âtape 3 : Property complexe pour les cheveux

```python
    @property
    def hairs(self):
        """Your docstring for Method"""
        # Retourne 'hair' ou 'hairs' selon ce qui existe
        return self.__dict__.get('hairs', self.__dict__.get('hair', 'dark'))
    
    @hairs.setter
    def hairs(self, value):
        """Your docstring for Method"""
        # Supprimer 'hair' et cr√©er 'hairs'
        if 'hair' in self.__dict__:
            del self.__dict__['hair']
        self.__dict__['hairs'] = value
```

**Explication :**
- **Getter complexe** : Cherche d'abord `hairs`, puis `hair`, sinon `'dark'`
- **Setter avec transformation** : Supprime `hair` et cr√©e `hairs`
- **Changement d'attribut** : `hair` (singulier) ‚Üí `hairs` (pluriel)

### √âtape 4 : M√©thodes d'interface publique

```python
    def get_eyes(self):
        """Your docstring for Method"""
        return self.eyes
    
    def set_eyes(self, value):
        """Your docstring for Method"""
        self.eyes = value
    
    def get_hairs(self):
        """Your docstring for Method"""
        return self.hairs
    
    def set_hairs(self, value):
        """Your docstring for Method"""
        self.hairs = value
```

**Explication :**
- **Interface publique** : M√©thodes `get_*` et `set_*` pour acc√®s externe
- **D√©l√©gation** : Ces m√©thodes utilisent les properties internes
- **Encapsulation** : S√©paration entre interface publique et impl√©mentation

---

## üß™ Tests et validation

### Code de test (tester.py) :

```python
from DiamondTrap import King

def main():
    """Test function for DiamondTrap module."""
    Joffrey = King("Joffrey")
    print(Joffrey.__dict__)
    Joffrey.set_eyes("blue")
    Joffrey.set_hairs("light")
    print(Joffrey.get_eyes())
    print(Joffrey.get_hairs())
    print(Joffrey.__dict__)

if __name__ == "__main__":
    main()
```

### Sortie attendue :

```
{'first_name': 'Joffrey', 'is_alive': True, 'family_name': 'Baratheon', 'eyes': 'brown', 'hair': 'dark'}
blue
light
{'first_name': 'Joffrey', 'is_alive': True, 'family_name': 'Baratheon', 'eyes': 'blue', 'hairs': 'light'}
```

### Analyse de la sortie :

**√âtat initial :**
- `family_name`: "Baratheon" (h√©rit√© de la classe Baratheon via MRO)
- `eyes`: "brown" (caract√©ristique Baratheon)
- `hair`: "dark" (singulier, caract√©ristique Baratheon)

**Apr√®s transformation :**
- `eyes`: "blue" (caract√©ristique Lannister)
- `hairs`: "light" (pluriel, caract√©ristique Lannister)
- L'attribut `hair` dispara√Æt, remplac√© par `hairs`

---

## üîç Analyse technique approfondie

### Method Resolution Order (MRO) :

```python
>>> King.__mro__
(<class 'DiamondTrap.King'>, <class 'S1E7.Baratheon'>, <class 'S1E7.Lannister'>, <class 'S1E9.Character'>, <class 'abc.ABC'>, <class 'object'>)
```

**Explication :**
- **Lin√©arisation C3** : Algorithme qui r√©sout l'ordre d'h√©ritage
- **Baratheon avant Lannister** : D√©termine quel constructeur est appel√©
- **√âvite le Diamond Problem** : Pas de duplication de `Character`

### Le Diamond Problem :

```
    Character
    /       \
Baratheon   Lannister
    \       /
      King
```

**Solution Python :**
- **C3 Linearization** : Garantit un ordre coh√©rent
- **Une seule instance** de `Character` dans l'h√©ritage
- **super()** fonctionne correctement dans ce contexte

---

## ‚úÖ V√©rifications de conformit√©

### Respect des r√®gles g√©n√©rales :
- ‚úÖ Python 3.10 utilis√©
- ‚úÖ Imports explicites
- ‚úÖ Aucune variable globale
- ‚úÖ Fonctions avec docstrings
- ‚úÖ Code conforme flake8

### Respect des instructions sp√©cifiques :
- ‚úÖ Pas de code dans le scope global (tester.py avec main())
- ‚úÖ Structure avec `if __name__ == "__main__"`
- ‚úÖ Toutes les classes/m√©thodes document√©es
- ‚úÖ Gestion d'exceptions appropri√©e

### Fonctionnalit√©s impl√©ment√©es :
- ‚úÖ H√©ritage multiple fonctionnel
- ‚úÖ Properties avec getters/setters
- ‚úÖ M√©thodes `get_*` et `set_*`
- ‚úÖ Transformation d'attributs (`hair` ‚Üí `hairs`)
- ‚úÖ Gestion correcte du MRO
- ‚úÖ Sortie conforme aux sp√©cifications

---

## üéì Points cl√©s √† retenir

### Concepts POO avanc√©s :
1. **H√©ritage multiple** : Puissant mais complexe, n√©cessite une compr√©hension du MRO
2. **Diamond Problem** : R√©solu √©l√©gamment par Python avec C3
3. **Properties** : Permettent un contr√¥le fin sur l'acc√®s aux attributs
4. **Encapsulation avanc√©e** : S√©paration interface publique/impl√©mentation priv√©e

### Sp√©cificit√©s Python :
1. **MRO** : Ordre d√©terministe et pr√©visible
2. **super()** : Fonctionne correctement avec l'h√©ritage multiple
3. **`__dict__`** : Manipulation directe possible mais √† utiliser avec pr√©caution
4. **Properties** : Syntaxe √©l√©gante pour getters/setters

### Bonnes pratiques :
1. **Documentation** : Essentielle pour du code complexe
2. **Tests** : V√©rification du comportement attendu
3. **Simplicit√©** : √âviter l'h√©ritage multiple quand possible
4. **Clart√©** : Code lisible malgr√© la complexit√© technique

---

## ‚ö†Ô∏è Pi√®ges et difficult√©s

### Pi√®ges courants :
1. **Confusion MRO** : Ne pas comprendre l'ordre d'appel des m√©thodes
2. **Properties mal con√ßues** : Effets de bord non d√©sir√©s
3. **Manipulation `__dict__`** : Peut casser l'encapsulation
4. **H√©ritage multiple** : Complexit√© accrue, bugs difficiles √† d√©boguer

### Difficult√©s de l'exercice :
1. **Changement d'attribut** : `hair` ‚Üí `hairs` pas √©vident
2. **Properties bidirectionnelles** : Getter et setter coh√©rents
3. **Gestion du MRO** : Comprendre quel constructeur est appel√©
4. **Sortie exacte** : Correspondre pr√©cis√©ment aux sp√©cifications

---

## üöÄ Extensions possibles

Pour aller plus loin, vous pourriez :
1. Impl√©menter d'autres properties (taille, √¢ge, titre)
2. Ajouter une validation dans les setters
3. Cr√©er un syst√®me de logs des changements d'attributs
4. Impl√©menter des properties calcul√©es (ex: ressemblance g√©n√©tique)
5. Ajouter des m√©thodes pour r√©v√©ler la vraie parent√©

Cet exercice illustre parfaitement les complexit√©s de l'h√©ritage multiple et l'√©l√©gance des solutions Python pour les g√©rer.