# Exercice 01 : GOT S1E7 - H√©ritage et m√©thodes sp√©ciales

## üìã Objectifs p√©dagogiques

### Concepts cl√©s abord√©s :
- **H√©ritage simple** : Cr√©ation de classes filles h√©ritant d'une classe abstraite
- **M√©thodes sp√©ciales** : Impl√©mentation de `__str__` et `__repr__`
- **M√©thodes de classe** : Utilisation du d√©corateur `@classmethod`
- **Extension d'attributs** : Ajout d'attributs sp√©cifiques aux classes filles
- **Appel du constructeur parent** : Utilisation de `super().__init__()`
- **Polymorphisme** : Diff√©rentes impl√©mentations de la m√™me interface

### Comp√©tences d√©velopp√©es :
- Conception hi√©rarchique orient√©e objet
- Manipulation des m√©thodes magiques Python
- Cr√©ation de factory methods avec `@classmethod`
- Gestion de l'h√©ritage et de l'extension de classes

---

## üéØ Consignes de l'exercice

**R√©pertoire de rendu :** `ex01/`  
**Fichiers √† rendre :** Fichiers des exercices pr√©c√©dents + `S1E7.py`  
**Fonctions autoris√©es :** Aucune

### Sp√©cifications :
1. Cr√©er deux familles h√©ritant de `Character` :
   - `Baratheon` avec attributs sp√©cifiques
   - `Lannister` avec attributs sp√©cifiques

2. Impl√©menter `__str__` et `__repr__` retournant des cha√Ænes

3. Cr√©er une m√©thode de classe `create_lannister` pour instanciation en cha√Æne

4. Contraintes :
   - Instanciation possible sans passer par `Character`
   - Toutes les m√©thodes doivent avoir des docstrings
   - Respecter flake8

---

## üîß √âl√©ments techniques

### Imports n√©cessaires :
```python
from S1E9 import Character
```

### Concepts Python utilis√©s :
- **H√©ritage simple** : `class Baratheon(Character)`
- **super()** : Appel du constructeur parent
- **M√©thodes magiques** : `__str__` et `__repr__`
- **@classmethod** : M√©thode de classe pour factory pattern
- **Type hints** : Annotations de types
- **f-strings** : Formatage moderne des cha√Ænes

---

## üíª Impl√©mentation pas √† pas

### √âtape 1 : Structure de base et h√©ritage

```python
from S1E9 import Character

class Baratheon(Character):
    """Representing the Baratheon family."""
    
    def __init__(self, first_name: str, is_alive: bool = True):
        """Your docstring for Constructor"""
        super().__init__(first_name, is_alive)  # Appel du constructeur parent
        # Attributs sp√©cifiques √† la famille
        self.family_name = "Baratheon"
        self.eyes = "brown"
        self.hairs = "dark"
```

**Explication :**
- `Baratheon(Character)` : H√©ritage de la classe abstraite Character
- `super().__init__()` : Appel du constructeur parent pour initialiser `first_name` et `is_alive`
- Ajout d'attributs sp√©cifiques : `family_name`, `eyes`, `hairs`

### √âtape 2 : M√©thodes sp√©ciales __str__ et __repr__

```python
    def __str__(self):
        """Your docstring for Method"""
        return f"Vector: ('{self.family_name}', '{self.eyes}', '{self.hairs}')"
    
    def __repr__(self):
        """Your docstring for Method"""
        return self.__str__()
```

**Explication :**
- `__str__` : Repr√©sentation "lisible" de l'objet (pour `print()`)
- `__repr__` : Repr√©sentation "officielle" de l'objet (pour debugging)
- Ici, les deux retournent la m√™me cha√Æne format√©e
- Format sp√©cifique : `Vector: ('famille', 'yeux', 'cheveux')`

### √âtape 3 : Impl√©mentation de la m√©thode abstraite

```python
    def die(self):
        """Your docstring for Method"""
        self.is_alive = False
```

**Explication :**
- Impl√©mentation obligatoire de la m√©thode abstraite h√©rit√©e de `Character`
- Change l'√©tat `is_alive` √† `False`

### √âtape 4 : Classe Lannister avec m√©thode de classe

```python
class Lannister(Character):
    """Your docstring for Class"""
    
    def __init__(self, first_name: str, is_alive: bool = True):
        """Your docstring for Constructor"""
        super().__init__(first_name, is_alive)
        self.family_name = "Lannister"
        self.eyes = "blue"      # Attributs diff√©rents
        self.hairs = "light"    # de Baratheon
    
    # ... m√©thodes __str__, __repr__, die() identiques ...
    
    @classmethod
    def create_lannister(cls, first_name: str, is_alive: bool = True):
        """Your docstring for Method"""
        return cls(first_name, is_alive)
```

**Explication :**
- `@classmethod` : D√©corateur pour m√©thode de classe
- `cls` : R√©f√©rence √† la classe elle-m√™me (pas √† l'instance)
- `return cls(...)` : Cr√©e une nouvelle instance de la classe
- **Factory pattern** : M√©thode alternative pour cr√©er des objets

---

## üß™ Tests et validation

### Code de test (tester.py) :

```python
from S1E7 import Baratheon, Lannister

def main():
    """Test function for S1E7 module."""
    # Test Baratheon
    Robert = Baratheon("Robert")
    print(Robert.__dict__)           # Attributs de l'instance
    print(Robert.__str__)            # M√©thode __str__
    print(Robert.__repr__)           # M√©thode __repr__
    print(Robert.is_alive)           # True
    Robert.die()                     # Appel de la m√©thode
    print(Robert.is_alive)           # False
    print(Robert.__doc__)            # Docstring de la classe
    
    print("---")
    
    # Test Lannister
    Cersei = Lannister("Cersei")
    print(Cersei.__dict__)
    print(Cersei.__str__)
    print(Cersei.is_alive)
    
    print("---")
    
    # Test m√©thode de classe
    Jaine = Lannister.create_lannister("Jaine", True)
    name_tuple = (Jaine.first_name, type(Jaine).__name__)
    print(f"Name : {name_tuple}, Alive : {Jaine.is_alive}")

if __name__ == "__main__":
    main()
```

### Sortie attendue :

```
{'first_name': 'Robert', 'is_alive': True, 'family_name': 'Baratheon', 'eyes': 'brown', 'hairs': 'dark'}
<bound method Baratheon.__str__ of Vector: ('Baratheon', 'brown', 'dark')>
<bound method Baratheon.__repr__ of Vector: ('Baratheon', 'brown', 'dark')>
True
False
Representing the Baratheon family.
---
{'first_name': 'Cersei', 'is_alive': True, 'family_name': 'Lannister', 'eyes': 'blue', 'hairs': 'light'}
<bound method Lannister.__str__ of Vector: ('Lannister', 'blue', 'light')>
True
---
Name : ('Jaine', 'Lannister'), Alive : True
```

---

## ‚úÖ V√©rifications de conformit√©

### Respect des r√®gles g√©n√©rales :
- ‚úÖ Python 3.10 utilis√©
- ‚úÖ Imports explicites
- ‚úÖ Aucune variable globale
- ‚úÖ Fonctions avec docstrings
- ‚úÖ Code conforme flake8

### Respect des instructions sp√©cifiques :
- ‚úÖ Pas de code dans le scope global (tester.py avec main())
- ‚úÖ Structure avec `if __name__ == "__main__"`
- ‚úÖ Toutes les classes/m√©thodes document√©es
- ‚úÖ Gestion correcte de l'h√©ritage

### Fonctionnalit√©s impl√©ment√©es :
- ‚úÖ Deux familles h√©ritant de Character
- ‚úÖ Attributs sp√©cifiques √† chaque famille
- ‚úÖ M√©thodes `__str__` et `__repr__` retournant des cha√Ænes
- ‚úÖ M√©thode de classe `create_lannister`
- ‚úÖ Impl√©mentation des m√©thodes abstraites
- ‚úÖ Instanciation possible sans passer par Character

---

## üéì Points cl√©s √† retenir

### Concepts POO avanc√©s :
1. **H√©ritage et extension** : Ajout d'attributs sp√©cifiques dans les classes filles
2. **M√©thodes magiques** : `__str__` et `__repr__` pour la repr√©sentation d'objets
3. **Factory pattern** : Utilisation de `@classmethod` pour cr√©er des instances
4. **super()** : Appel correct du constructeur parent

### Bonnes pratiques Python :
1. **Type hints** : Annotations coh√©rentes sur tous les param√®tres
2. **Docstrings** : Documentation compl√®te de toutes les entit√©s
3. **PEP8** : Respect des conventions de formatage
4. **S√©paration des responsabilit√©s** : Module vs programme de test

### Architecture logicielle :
1. **Hi√©rarchie de classes** : Organisation logique des familles
2. **Polymorphisme** : M√™me interface, impl√©mentations diff√©rentes
3. **Extensibilit√©** : Facilit√© d'ajout de nouvelles familles
4. **R√©utilisabilit√©** : Code modulaire et bien structur√©

---

## üöÄ Extensions possibles

Pour aller plus loin, vous pourriez :
1. Ajouter d'autres familles (Targaryen, Tully, Martell)
2. Impl√©menter des m√©thodes sp√©cifiques √† chaque famille
3. Cr√©er des relations entre familles (alliances, guerres)
4. Ajouter des attributs dynamiques (√¢ge, titre, localisation)
5. Impl√©menter d'autres m√©thodes magiques (`__eq__`, `__lt__`, etc.)

Cet exercice approfondit les concepts d'h√©ritage et introduit les m√©thodes sp√©ciales Python, essentielles pour une POO avanc√©e.