# Exercice 00 : GOT S1E9 - Classes abstraites et h√©ritage

## üìã Objectifs p√©dagogiques

### Concepts cl√©s abord√©s :
- **Classes abstraites** : Comprendre le concept d'abstraction en POO
- **H√©ritage** : Impl√©mentation de l'h√©ritage simple en Python
- **M√©thodes abstraites** : Utilisation du d√©corateur `@abstractmethod`
- **Module ABC** : Manipulation du module Abstract Base Classes de Python
- **Docstrings** : Documentation des classes et m√©thodes
- **Encapsulation** : Gestion des attributs d'instance

### Comp√©tences d√©velopp√©es :
- Conception orient√©e objet
- Respect des conventions Python (PEP8)
- Gestion d'erreurs et exceptions
- Tests et validation de code

---

## üéØ Consignes de l'exercice

**R√©pertoire de rendu :** `ex00/`  
**Fichiers √† rendre :** `S1E9.py`  
**Fonctions autoris√©es :** Aucune

### Sp√©cifications :
1. Cr√©er une classe abstraite `Character` avec :
   - Param√®tre `first_name` (obligatoire)
   - Param√®tre `is_alive` (optionnel, d√©faut = True)
   - M√©thode abstraite pour changer `is_alive` de True √† False

2. Cr√©er une classe `Stark` h√©ritant de `Character`

3. Contraintes :
   - Impossible d'instancier `Character` directement
   - Toutes les m√©thodes doivent avoir des docstrings
   - Respecter flake8

---

## üîß √âl√©ments techniques

### Imports n√©cessaires :
```python
from abc import ABC, abstractmethod
```

### Concepts Python utilis√©s :
- **ABC (Abstract Base Classes)** : Classe de base pour cr√©er des classes abstraites
- **@abstractmethod** : D√©corateur pour d√©finir des m√©thodes abstraites
- **H√©ritage simple** : `class Stark(Character)`
- **Type hints** : Annotations de types pour les param√®tres
- **Docstrings** : Documentation int√©gr√©e au code

---

## üíª Impl√©mentation pas √† pas

### √âtape 1 : Imports et structure de base

```python
from abc import ABC, abstractmethod
```

**Explication :** 
- `ABC` : Classe de base abstraite fournie par Python
- `abstractmethod` : D√©corateur pour marquer les m√©thodes comme abstraites

### √âtape 2 : D√©finition de la classe abstraite Character

```python
class Character(ABC):
    """Your docstring for Class"""
    
    def __init__(self, first_name: str, is_alive: bool = True):
        """Your docstring for Constructor"""
        self.first_name = first_name
        self.is_alive = is_alive
```

**Explication :**
- `Character(ABC)` : H√©ritage de ABC pour cr√©er une classe abstraite
- `__init__` : Constructeur avec param√®tres typ√©s
- `first_name: str` : Param√®tre obligatoire de type string
- `is_alive: bool = True` : Param√®tre optionnel avec valeur par d√©faut
- `self.first_name` et `self.is_alive` : Attributs d'instance

### √âtape 3 : M√©thode abstraite

```python
    @abstractmethod
    def die(self):
        """Your docstring for Method"""
        pass
```

**Explication :**
- `@abstractmethod` : D√©corateur qui rend la m√©thode abstraite
- `pass` : Instruction vide car la m√©thode sera impl√©ment√©e dans les classes filles
- Cette m√©thode DOIT √™tre impl√©ment√©e dans toute classe h√©ritant de Character

### √âtape 4 : Classe concr√®te Stark

```python
class Stark(Character):
    """Your docstring for Class"""
    
    def die(self):
        """Your docstring for Method"""
        self.is_alive = False
```

**Explication :**
- `Stark(Character)` : H√©ritage de la classe Character
- Impl√©mentation obligatoire de la m√©thode abstraite `die()`
- `self.is_alive = False` : Change l'√©tat du personnage

---

## üß™ Tests et validation

### Code de test (tester.py) :

```python
from S1E9 import Character, Stark

def main():
    """Test function for S1E9 module."""
    # Test de cr√©ation et manipulation d'un Stark
    Ned = Stark("Ned")
    print(Ned.__dict__)           # Affiche les attributs
    print(Ned.is_alive)           # True
    Ned.die()                     # Appel de la m√©thode
    print(Ned.is_alive)           # False
    
    # Test des docstrings
    print(Ned.__doc__)            # Docstring de la classe
    print(Ned.__init__.__doc__)   # Docstring du constructeur
    print(Ned.die.__doc__)        # Docstring de la m√©thode
    
    print("---")
    
    # Test avec param√®tre is_alive = False
    Lyanna = Stark("Lyanna", False)
    print(Lyanna.__dict__)
    
    # Test de la classe abstraite (doit lever une erreur)
    try:
        Character("hodor")
    except TypeError as e:
        print(f"Erreur attendue: {e}")

if __name__ == "__main__":
    main()
```

### Sortie attendue :

```
{'first_name': 'Ned', 'is_alive': True}
True
False
Your docstring for Class
Your docstring for Constructor
Your docstring for Method
---
{'first_name': 'Lyanna', 'is_alive': False}
Erreur attendue: Can't instantiate abstract class Character without an implementation for abstract method 'die'
```

---

## ‚úÖ V√©rifications de conformit√©

### Respect des r√®gles g√©n√©rales :
- ‚úÖ Python 3.10 utilis√©
- ‚úÖ Imports explicites
- ‚úÖ Aucune variable globale
- ‚úÖ Fonctions avec docstrings
- ‚úÖ Code conforme flake8

### Respect des instructions sp√©cifiques :
- ‚úÖ Pas de code dans le scope global (tester.py avec main())
- ‚úÖ Structure avec `if __name__ == "__main__"`
- ‚úÖ Gestion d'exceptions (try/except pour test classe abstraite)
- ‚úÖ Toutes les classes/m√©thodes document√©es

### Fonctionnalit√©s impl√©ment√©es :
- ‚úÖ Classe abstraite fonctionnelle
- ‚úÖ Impossible d'instancier Character directement
- ‚úÖ H√©ritage correct de Stark
- ‚úÖ M√©thode die() impl√©ment√©e
- ‚úÖ Param√®tres first_name et is_alive g√©r√©s
- ‚úÖ Docstrings conformes √† la sortie attendue

---

## üéì Points cl√©s √† retenir

### Concepts POO :
1. **Abstraction** : Une classe abstraite d√©finit un contrat que les classes filles doivent respecter
2. **H√©ritage** : Permet de r√©utiliser et √©tendre le comportement d'une classe parent
3. **Polymorphisme** : Diff√©rentes classes peuvent impl√©menter la m√™me m√©thode diff√©remment

### Bonnes pratiques Python :
1. **Type hints** : Am√©liore la lisibilit√© et aide au debugging
2. **Docstrings** : Documentation essentielle pour la maintenance du code
3. **PEP8** : Respect des conventions de style Python
4. **Gestion d'erreurs** : Utilisation appropri√©e de try/except

### Architecture logicielle :
1. **S√©paration des responsabilit√©s** : Classe abstraite vs impl√©mentation concr√®te
2. **Contrat d'interface** : Les m√©thodes abstraites d√©finissent ce qui doit √™tre impl√©ment√©
3. **Extensibilit√©** : Facilit√© d'ajout de nouvelles "maisons" (Lannister, Baratheon, etc.)

---

## üöÄ Extensions possibles

Pour aller plus loin, vous pourriez :
1. Ajouter d'autres maisons (Lannister, Baratheon, Targaryen)
2. Impl√©menter d'autres m√©thodes abstraites (attack, defend)
3. Ajouter des attributs sp√©cifiques √† chaque maison
4. Cr√©er une hi√©rarchie plus complexe avec des sous-classes

Cet exercice pose les bases de la programmation orient√©e objet qui seront utilis√©es dans les exercices suivants du module.